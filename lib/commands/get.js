// MAKE node-FORMAT MODULE LOOK LIKE AMD-FORMAT
var define;
if (typeof define !== 'function') {
    define = require('amdefine')(module);
}

define(function(require) {

/* External */
var JSON = require('JSON');
const fs = require('fs');
var q = require('q');
var moment = require('moment');

/* Internal */
var logger = require('./logger');
var util       = require("../utils/util");

var getter = {

  util : util,

  /*
  * Retrieves objects defined in bcotool validation error output from the original JSON data file.
  *
  * @param String error text with JSON containing the error output generated by bcotool
  * @param String data_file containing data to be validated
  * @api public
  */
  get : function ( error_output ) {
    // logger.log("error_output", error_output);
    

    var data = JSON.parse( error_output );
    // logger.log("data", data);

    var errors = data.errors;
    var data_file   = data.file;

    var deferred = q.defer();
    var thisObj = this;

    setTimeout( function () {

      try {
        // logger.log("data_file", data_file);
        // logger.log("errors", errors);

        var output = [];
        var data_object = util.jsonFileToData( data_file );
        // logger.log("data_object", data_object);

        for (var i = 0; i < errors.length; i++) {
          var error = errors[i];
          // logger.log("error", error);
          var fields = error.depth.split(":");
          // logger.log("fields", fields);

          var sub_object = thisObj.getSubObject(data_object, fields);
          // logger.log("sub_object", sub_object);

          var object_name = error.depth.match(/[^:]+$/)[0];
          // logger.log("object_name", object_name);

          var entry = {};
          entry.error = error.error;
          entry.depth = error.depth;
          entry[object_name] = sub_object;

          output.push( entry );

        };

        return deferred.resolve( output );
      }
      catch (err) {
        logger.log("err.message", err.message);
        if (err.stack) {
          // logger.error(err.stack);
        }
        else {
          //// logger.error("err " + "[" + err.lineNumber + "]", err);
           return deferred.resolve(result.stderr);
        }
      }
    },
    50);

    // logger.log("Returning deferred promise", deferred.promise)
    return deferred.promise;
  },

  getSubObject : function ( data_object, fields ) {
    var field = fields.shift();
    // logger.log("field", field);
    // logger.log("fields", fields);

    var sub_object = data_object[field];
    if ( fields.length == 0 ) {
      return sub_object;
    }
    else {
      return this.getSubObject( sub_object, fields );
    }
  }

}



return getter;

});

